<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<title>Minecraft</title>
	<style>
		body {
			margin: 0;
		}

		canvas {
			width: 100%;
			height: 100%
		}

		#crosshair {
			position: absolute;
			color: #fff;
			font-size: 20px;
			font-weight: bold;
			left: 50%;
			top: 50%;
			transform: translate3d(-50%, -50%, 0);
		}
		#progress::after {
			position: absolute;
			height: 50px; width: 50px;
			border-radius: 50%;
			background: #fff;
			content: '';
			transform: scale(0);
		}
		#progress {
			position: absolute;
			left: 50%; top: 50%;
			height: 50px; width: 50px;
			border-radius: 50%;
			border: 2px solid #fff;
			opacity: 0;
			transform: translate3d(-50%, -50%, 0);
		}
		#progress.show {
			opacity: 0.8;
		}
		#progress.show::after {
			transform: scale(1);
			transition: transform 400ms linear;
		}
	</style>
</head>
<body>
<div id="crosshair">+</div>
<div id="progress"></div>
<script src="three.js"></script>
<script src="pointerLock.js"></script>
<script src="terrain.js"></script>
<script src="noise.js"></script>
<script src="luminance.js"></script>
<script src="controls.js"></script>
<script src="stats.js"></script>
<script>
	'use strict';

	var scene, camera, renderer, controls, raycaster, spotLight, cursor, windowHeight, windowWidth, progress;
	var moveForward, moveBackward, moveLeft, moveRight, canJump, playerHeight, prevTime, velocity, cubes, player, speed;
	var geometryBlock, geometryWater, materials, terrain = [], arrowHelper;
	var mapSize = 32, stats;

	function init () {
		// init threejs
		scene = new THREE.Scene;
		windowHeight = window.innerHeight;
		windowWidth = window.innerWidth;

		camera = new THREE.PerspectiveCamera(60, windowWidth / windowHeight, 0.2, 30);
		renderer = new THREE.WebGLRenderer();
		controls = new THREE.PointerLockControls(camera);
		raycaster = new THREE.Raycaster();
		cursor = new THREE.Vector2();
		progress = document.getElementById('progress');

		// controls
		moveForward = false;
		moveBackward = false;
		moveLeft = false;
		moveRight = false;
		canJump = true;
		playerHeight = 2;
		prevTime = performance.now();
		velocity = new THREE.Vector3();
		speed = 0.1;
		cubes = [];

		scene.add(controls.getObject());
		controls.getObject().position.set(mapSize/2, 2, mapSize/2);
		renderer.setPixelRatio( 1 );
		renderer.setSize(windowWidth, windowHeight);
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.soft = false;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;
		renderer.shadowMap.renderReverseSided = false;
		document.body.appendChild(renderer.domElement);
		stats = new Stats();
		document.body.appendChild( stats.dom );


//		 var axisHelper = new THREE.AxisHelper( 50 );
//		 scene.add( axisHelper );

		// init lighting
		var ambientLight = new THREE.AmbientLight(0x666666);
		scene.add(ambientLight);
		spotLight = new THREE.SpotLight(0x999999);
		spotLight.position.set(70, 50, 0);
		spotLight.castShadow = true;
		spotLight.shadow.darkness = 0.1;
		spotLight.shadow.camera.near = 30;
		spotLight.shadow.camera.far = 100;
		spotLight.shadow.camera.fov = 80;
		spotLight.shadow.mapSize.width = 1024;
		spotLight.shadow.mapSize.height = 1024;
		spotLight.shadow.bias = -0.002;
		scene.add(spotLight);
//		 scene.add(new THREE.DirectionalLightHelper(directionalLight1));
		 scene.add(new THREE.CameraHelper( spotLight.shadow.camera ));
//		scene.fog = new THREE.Fog(0x000000, 5, 20);

		// load textures
		var loader = new THREE.TextureLoader();
		var texture_grass_top = new THREE.MeshLambertMaterial(),
				texture_grass_side = new THREE.MeshLambertMaterial(),
				texture_water = new THREE.MeshLambertMaterial(),
				texture_dirt = new THREE.MeshLambertMaterial();

		loader.load('/images/grass.png', function (texture) {
			texture_grass_top.map = texture;
			texture_grass_top.needsUpdate = true;
		});
		loader.load('/images/grass_dirt.png', function (texture) {
			texture_grass_side.map = texture;
			texture_grass_side.needsUpdate = true;
		});
		loader.load('/images/dirt.png', function (texture) {
			texture_dirt.map = texture;
			texture_dirt.needsUpdate = true;
		});
		loader.load('/images/water.jpg', function (texture) {
			texture_water.map = texture;
			texture_water.transparent = true;
			texture_water.opacity = 0.7;
			texture_water.needsUpdate = true;
		});

		// init terrain
		geometryBlock = new THREE.BoxGeometry(1, 1, 1);
		geometryWater = new THREE.BoxGeometry(1, 0.8, 1);
		materials = {
			blockGrass: new THREE.MeshFaceMaterial([texture_grass_side, texture_grass_side, texture_grass_top, texture_dirt, texture_grass_side, texture_grass_side]),
			blockDirt: new THREE.MeshFaceMaterial([texture_dirt, texture_dirt, texture_dirt, texture_dirt, texture_dirt, texture_dirt]),
			blockWater: new THREE.MeshFaceMaterial([texture_water, texture_water, texture_water, texture_water, texture_water, texture_water])
		};


		// perlin noise terrain

		noise.seed(Math.random());
		for (var x = 0; x < mapSize; x++) {
			terrain[x] = [];
			for (var y = 0; y < mapSize; y++) {
				var value = Math.floor(Math.abs(noise.perlin2(x / mapSize, y / mapSize)) * 20);
				terrain[x][y] = value;
			}
		}

		// diamond square terrain
		// var terrain = diamondSquareTerrain(5);
		for (var i = 0; i < terrain.length; i++) {
			for (var j = 0; j < terrain[i].length; j++) {
				var height = terrain[i][j];
				var cube;
				for (var h = 0; h <= height; h++) {
					var cube2 = null;
					if (h === height) {
						if(h === 0) {
							cube = new THREE.Mesh(geometryBlock, texture_dirt, 0);
							cube2 = new THREE.Mesh(geometryWater, texture_water, 0);
						} else {
							cube = new THREE.Mesh(geometryBlock, materials['blockGrass'], 0);
						}
					} else {
						cube = new THREE.Mesh(geometryBlock, texture_dirt, 0);
					}
					cube.castShadow = true;
					cube.receiveShadow = true;
					cube.position.set(i + 0.5, h, j + 0.5);
//					cubes.push(cube);
					scene.add(cube);

					if(cube2) {
						cube2.position.set(i + 0.5, h + 1 - 0.1, j + 0.5);
						scene.add(cube2);
					}
				}
			}
		}

//		player = new THREE.Mesh(geometryBlock, texture_dirt);
//
//		player.position.set(0, 10, -10);
//		player.castShadow = true;
//		scene.add(player);

		render();
	}

	function getObjectAtCursor() {
		raycaster.ray.origin.copy(controls.getObject().position);
		raycaster.ray.direction.copy(camera.getWorldDirection());
		// raycaster.ray.far = 3;
		var intersections = raycaster.intersectObjects(scene.children);
		if(intersections.length) {
			return intersections[0].object;
		}
		return null;
	}

	function removeObject(object) {
		object && scene.remove(object);
//		var pos = object.position;
//		terrain[Math.floor(pos.x)][Math.floor(pos.z)]--;
	}

	// game loop
//	var startTime = Date.now();
	var prevTime;
	function render () {
		var prevx = Math.floor(controls.getObject().position.x);
		var prevz = Math.floor(controls.getObject().position.z);
		var prevcellHeight = terrain[prevx][prevz];

		requestAnimationFrame(render);
//		checkControls();
//		 var currentTime = Date.now();
//		 var elapsedTime = (currentTime - startTime)/1000;
//		 var localTime = ((elapsedTime % 1200) / 1200) + 0.85;
//		 spotLight.position.y = 30 * Math.cos(localTime * 2 * Math.PI);
//		 spotLight.position.x = 30 * Math.sin(localTime * 2 * Math.PI);

		if(moveForward) {
			controls.getObject().translateZ(-speed);
		}
		if(moveBackward) {
			controls.getObject().translateZ(speed);
		}
		if(moveLeft) {
			controls.getObject().translateX(-speed);
		}
		if(moveRight) {
			controls.getObject().translateX(speed);
		}

		var x = Math.floor(controls.getObject().position.x);
		var z = Math.floor(controls.getObject().position.z);
		var cellheight = terrain[x][z];

		if(cellheight > prevcellHeight && canJump) {
			if(moveForward) {
				controls.getObject().translateZ(speed);
			}
			if(moveBackward) {
				controls.getObject().translateZ(-speed);
			}
			if(moveLeft) {
				controls.getObject().translateX(speed);
			}
			if(moveRight) {
				controls.getObject().translateX(-speed);
			}
		}

		x = Math.floor(controls.getObject().position.x);
		z = Math.floor(controls.getObject().position.z);
		cellheight = terrain[x][z];

		var time = performance.now();
		var delta = ( time - prevTime ) / 1000;

		velocity.y -= 35 * delta;
		controls.getObject().translateY( velocity.y * delta );

		if ( controls.getObject().position.y < cellheight + playerHeight ) {

			velocity.y = 0;
			controls.getObject().position.y = cellheight + playerHeight;
			canJump = true;

		}
		prevTime = time;

		stats.update();
		renderer.render(scene, camera);
	}

	window.onload = init();


</script>
</body>
</html>
